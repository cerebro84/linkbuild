/*
 * ChatMain.java
 *
 * Created on 7 gennaio 2008, 22.18
 */

/**
    @author Massimo Domenico Sammito
*/
import com.jsoft.linkbuild.utility.*;
import com.jsoft.linkbuild.listenerAndServerLibrary.*;
import javax.swing.*;
import java.security.*;
import java.util.*;
import java.awt.event.*;

/* Per effettuare correttamente gli import dei package della libreria e necessario
 * che sia prima impostato il CLASSPATH
 */

public class ChatMain extends javax.swing.JFrame implements LinkBuildApp
{
    
    private int password;
    private Hashtable nicks;
    private Hashtable users;
    private DefaultSessionRule dsf;
    private MySimpleRule msr;
    private BanConf bf;
    private int contGuest=0;
       
    /** Creates new form ChatMain */
    public ChatMain(int password) 
    {
        this.password = password;
        this.nicks = new Hashtable<String,String[]>(); //IDUSER / FIELDS
        this.users = new Hashtable<String,String>(); //NICK / IDUSER
        this.dsf = new DefaultSessionRule(this.password);
        this.msr = new MySimpleRule();
        this.bf = new BanConf();
        this.bf.setFloodingControl(true);
        this.bf.setWordControl(true);
        
        BanningRule [] bar = new BanningRule[1];
        bar[0] = bf;
        LogManager.getInstance().addLogger(password, LogManager.BANNING);
        LogManager.getInstance().addLogger(password, LogManager.REGISTRATION);
        LogManager.getInstance().addLogger(password, LogManager.SESSION);
        LogManager.getInstance().setRedirect(password);
        RegistrationManager.getInstance().addRegistration(password, msr);
        SessionManager.getInstance().addSession(this.password, dsf);
        BanManager.getInstance().addBanManagerFor(password, bar);
          
        initComponents();
        setVisible(true);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenuBar2 = new javax.swing.JMenuBar();
        jMenu3 = new javax.swing.JMenu();
        jMenu4 = new javax.swing.JMenu();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenu2 = new javax.swing.JMenu();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenu2 = new javax.swing.JMenu();

        jMenu3.setText("File");
        jMenuBar2.add(jMenu3);

        jMenu4.setText("Edit");
        jMenuBar2.add(jMenu4);

        setTitle("ChatJSOFT");
        setBounds(new java.awt.Rectangle(0, 0, 400, 400));
        setMinimumSize(new java.awt.Dimension(400, 400));
        setResizable(false);
        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setDefaultLookAndFeelDecorated(true);
        setAlwaysOnTop(true);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setLineWrap(true);
        jTextArea1.setWrapStyleWord(true);
        jTextArea1.setCaretPosition(jTextArea1.getDocument().getLength());
        jScrollPane1.setViewportView(jTextArea1);

        jTextArea2.setColumns(20);
        jTextArea2.setEditable(false);
        jTextArea2.setRows(5);
        jTextArea2.setLineWrap(true);
        jTextArea2.setWrapStyleWord(true);
        jTextArea2.setCaretPosition(jTextArea1.getDocument().getLength());
        jScrollPane3.setViewportView(jTextArea2);

        jTextArea3.setBackground(new java.awt.Color(204, 204, 255));
        jTextArea3.setColumns(18);
        jTextArea3.setEditable(false);
        jTextArea3.setRows(5);
        jTextArea3.setLineWrap(true);
        jTextArea3.setWrapStyleWord(true);
        jTextArea3.setCaretPosition(jTextArea1.getDocument().getLength());
        jScrollPane4.setViewportView(jTextArea3);

        jList1.setModel(new DefaultListModel());
        jList1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane2.setViewportView(jList1);

        jMenu1.setText("File");
        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        jMenu1.setText("File");
        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 357, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 117, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 236, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 239, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 230, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 230, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                        .addGap(11, 11, 11))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 137, Short.MAX_VALUE)
                        .addContainerGap())))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
        
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList jList1;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenu jMenu4;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuBar jMenuBar2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    // End of variables declaration//GEN-END:variables

    public boolean newUserRegistered(String IDUser)
    {
       try
       {
            DefaultListModel dlm = (DefaultListModel) jList1.getModel();
       
            if(!this.users.containsKey(IDUser))
            {
                contGuest++;
                this.users.put(IDUser, new String[]{"guest"+contGuest,"",""});
                this.nicks.put("guest"+contGuest, IDUser);

                dlm.add(dlm.getSize(), "guest"+contGuest);
                jTextArea3.append("Nuovo utente ID: "+IDUser+"  nick: guest"+contGuest+"\n");
                jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());
            }
                   
            //mando la lista alla midlet
            String[] lista = new String[dlm.size()+1];
            lista[0] = "lista";
            String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];
            String[] entra = new String[2];
            entra[0] = "entra";
            entra[1] = nickDiIDUser;
       
            for(int i=1; i<lista.length; i++)
            {
                String tizio = (String)(dlm.get(i-1));
                if(!(tizio.equals(nickDiIDUser)))
                {
                    lista[i] = tizio;
                    //notifico a tutti gli altri utenti che e entrato un nuovo utente
                    ConnectionServer.getInstance().send(password, entra, ((String)(this.nicks.get(tizio))));
                }
                else
                {
                    //sto trattando proprio l'utente a cui inviare la lista
                    //decidere se inserirlo o meno nella lista commentando o decommentando
                    //opportuna la riga seguente.
                    lista[i] = tizio;
                }
            }
       
            ConnectionServer.getInstance().send(password, lista, IDUser); //invio la lista all'utente appena entrato
            return true;
         }
         catch(AccessControlException e)
         {
             JOptionPane.showMessageDialog(null, ""+e.toString(), "ATTENZIONE", JOptionPane.ERROR_MESSAGE);
             return false;
         }
    }

    public boolean userDisconnected(String IDUser)
    {
        try
        {
            DefaultListModel dlm = (DefaultListModel) jList1.getModel();
            String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];
            dlm.removeElement(nickDiIDUser);
            this.users.remove(IDUser);
            this.nicks.remove(nickDiIDUser);
            jTextArea3.append("Utente Disconnesso: "+nickDiIDUser+"\n");
            jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());
        
            String[] esce = new String[2];
            esce[0] = "esce";
            esce[1] = nickDiIDUser;
       
            for(int i=0; i<dlm.size(); i++)
            {
                String tizio = (String)(dlm.get(i));
                //notifico a tutti gli altri utenti che e uscito un utente
                ConnectionServer.getInstance().send(password, esce, ((String)(this.nicks.get(tizio))));
            }
            return true;
        }
        catch(AccessControlException e)
        {
           JOptionPane.showMessageDialog(null, ""+e.toString(), "ATTENZIONE", JOptionPane.ERROR_MESSAGE);
           return false;
        }
    }
     
    public boolean userAbnormalDisconnected(String IDUser)
    {
        String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];
        userDisconnected(IDUser);    
        jTextArea3.append("Utente ID: "+IDUser+"  nick: "+nickDiIDUser+" Disconnesso in modo ANORMALE\n");
        jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

        return true;
    }
    
    public boolean userDisconnectedForPing(String IDUser)
    {
        String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];
        userDisconnected(IDUser);    
        jTextArea3.append("Utente ID: "+IDUser+"  nick: "+nickDiIDUser+" Disconnesso per Ping Out\n");
        jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

        return true;
    }

    public boolean userDisconnectedForSysBan(String IDUser, String message)
    {
        String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];   
        userDisconnected(IDUser);    
        jTextArea3.append("Utente ID: "+IDUser+"  nick: "+nickDiIDUser+" Disconnesso per Banning del Sistema\n");
        jTextArea3.append("Causa: "+message+"\n");
        jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

        return true;
    }

    public boolean userDisconnectedForAppBan(String IDUser, String message)
    {
        String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];   
        userDisconnected(IDUser);    
        jTextArea3.append("Utente ID: "+IDUser+"  nick: "+nickDiIDUser+" Disconnesso per Banning dell'Applicazione\n");
        jTextArea3.append("Causa: "+message+"\n");
        jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

        return true;
    }

    //questo metodo e comunque invocato dopo del newUserRegistered.
    public boolean userRegistrationFields(String IDUser, String[] fields)
    {
        if(this.users.containsKey(IDUser))
        {
            String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];
            this.users.remove(IDUser);
            this.users.put(IDUser, fields);
            this.nicks.remove(nickDiIDUser);
            this.nicks.put(fields[0], IDUser);
            DefaultListModel dlm = (DefaultListModel) jList1.getModel();
            dlm.set(dlm.indexOf(nickDiIDUser), fields[0]);
            
            String[] nick = new String[3];
            nick[0] = "nick";
            nick[1] = nickDiIDUser;
            nick[2] = fields[0];
            for(int i=0; i<dlm.size(); i++)
            {
                String tizio = (String)(dlm.get(i));
                //notifico a tutti gli altri utenti che un utente ha cambiato nick
                ConnectionServer.getInstance().send(password, nick, ((String)(this.nicks.get(tizio))));
            }
            
            jTextArea3.append(""+nickDiIDUser+" è adesso"+" 'nick': "+fields[0]+"\n");
            jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

            contGuest--;
            return true;
        }
        else
            return false;
    }

    public boolean onClosing()
    {
        //this.setVisible(false);
        System.out.println("Come pensavo chiama prima onClosing");
        System.out.println("Faccio il dispose di ChatMain");
        this.dispose();
        System.out.println("ChatMain dispose eseguito");
        return true;
    }

    public boolean stringIncoming(String IDUser, String message)
    {
        return false;
    }

    public boolean stringArrayIncoming(String IDUser, String[] messages)
    {
        try
        {
            String nickDiIDUser = ((String[])(this.users.get(IDUser)))[0];  
            DefaultListModel dlm = (DefaultListModel) jList1.getModel();
            // messages[0] = "nick" --- messages[1] = (nick corrispondente all'ID bluetooth)
            if(messages[0].equals("nick"))
            {
                dlm.set(dlm.indexOf(nickDiIDUser), messages[1]);
                String[] info = (String[])this.users.get(IDUser);
                info[0] = messages[1];
                this.users.remove(IDUser);
                this.nicks.remove(nickDiIDUser);
                this.users.put(IDUser, info);
                this.nicks.put(messages[1], IDUser);
                
                String[] nick = new String[3];
                nick[0] = "nick";
                nick[1] = nickDiIDUser;
                nick[2] = messages[1];
                for(int i=0; i<dlm.size(); i++)
                {
                    String tizio = (String)(dlm.get(i));
                    //notifico a tutti gli altri utenti che un utente ha cambiato nick
                    ConnectionServer.getInstance().send(password, nick, ((String)(this.nicks.get(tizio))));
                }
                jTextArea3.append(nickDiIDUser+" diventa "+messages[1]+"\n");
                jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

                return true;
            }// messages[0] = "pubblico" --- messages[1] = (messaggio da scrivere in pubblica)
            else if(messages[0].equals("pubblico"))
            {
                jTextArea1.append("<"+nickDiIDUser+">  "+messages[1]+"\n");
                jTextArea1.setCaretPosition(jTextArea1.getDocument().getLength());
                jTextArea3.append(nickDiIDUser+" scrive in pubblica"+"\n");
                jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

                return true;
            
            } //messages[0] = "privato" --- messages[1]= (messaggio da mandare) --- messages[2]= (utente che deve ricevere il messaggio)
            else if(messages[0].equals("privato"))
            {
                String userDelNick = (String)(this.nicks.get(messages[2]));  
                String[] privato = new String[3];
                privato[0] = "privato";
                privato[1] = nickDiIDUser;
                privato[2] = messages[1];
                ConnectionServer.getInstance().send(password, privato, userDelNick);
                jTextArea3.append(nickDiIDUser+" scrive in privato\n");
                jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

                return true;
            }
            else if(messages[0].equals("nome"))
            {
                String userDelNick = (String)(this.nicks.get(messages[1]));  
                String[] nome = new String[3];
                nome[0] = "nome";
                nome[1] = messages[1];
                nome[2] = ((String[])(this.users.get(userDelNick)))[1];
                ConnectionServer.getInstance().send(password, nome, IDUser);
                jTextArea3.append(nickDiIDUser+" chiede il vero nome di "+(messages[1])+"\n");
                jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

                return true;
            }
            else if(messages[0].equals("email"))
            {
                String userDelNick = (String)(this.nicks.get(messages[1]));  
                String[] email = new String[3];
                email[0] = "email";
                email[1] = messages[1];
                email[2] = ((String[])(this.users.get(userDelNick)))[2];
                ConnectionServer.getInstance().send(password, email, IDUser);
                jTextArea3.append(nickDiIDUser+" chiede l'email di "+(messages[1])+"\n");
                jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

                return true;
            }
            else
                return false;
            
            /*
             * ATTENZIONE: Quando l'utente si vuole disconnettere lo fa sapere lui direttamente
             * al server, e poi il server comunica questo fatto all'applicazione oppure, deve chiedere
             * all'applicazione server di chiedere alla libreria di disconnetterlo, attraverso un codice
             * stile stringIncoming(String message) dove message contiene "disconnect".
             * Io credo vhe abbiamo implementato  il primo metodo e che sia anche quello piu giusto.
             */
        }
        catch(AccessControlException e)
        {
            JOptionPane.showMessageDialog(null, ""+e.toString(), "ATTENZIONE", JOptionPane.ERROR_MESSAGE);
             return false;
        }
    }
    
    public boolean booleanIncoming(String IDUser, boolean message)
    {
        return false;
    }
    
    public boolean integerIncoming(String IDUser, int message)
    {
       return false;
    }
    
    public boolean byteIncoming(String IDUser, byte message)
    {
       return false;
    }
    
    public boolean charIncoming(String IDUser, char message)
    {
       return false;
    }

    public boolean byteArrayIncoming(String IDUser, byte[] message)
    {
       return false;
    }
                                    
    public boolean logIncoming(String log)
    {
        jTextArea2.append(log+"\n");
        jTextArea2.setCaretPosition(jTextArea2.getDocument().getLength());

        return true;
    }

    public boolean userSessionFields(String IDUser, Object[] fields)
    {
        String dati = "";
        String[] campi = (String[])(fields);
        
        jTextArea3.append(this.dsf.makeNiceAnalysis(campi));
        jTextArea3.setCaretPosition(jTextArea3.getDocument().getLength());

        return true;
    }
}
